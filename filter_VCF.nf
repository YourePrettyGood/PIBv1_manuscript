#!/usr/bin/env nextflow
/* Pipeline for filtering VCFs                                           *
 * Filters:                                                              *
 *  ExcHet and HWE                                                       *
 *  Indel proximity                                                      *
 *  Per-site missingness                                                 *
 *  BED-based masks (CpG, genomicSuperDups, hs37m_mask35_50)             *
 *  Archaic filterBeds (AltaiNea, Vindija33.19, Chagyrskaya, Denisova)   *
 * Genotype-level filters:                                               *
 *  Minimum DP, minimum GQ                                               *
 *  Binned maximum DP                                                    */

//Filtering thresholds:
//Note: We also set a 0 missingness filter automatically
params.exchet_thresh = "0.0001"
params.hwe_thresh = "0.0001"
params.indelprox_thresh = "5"
params.missing_thresh = "0.05"
params.mindp_thresh = "10"
params.mingq_thresh = "30"
//MAPQ threshold is for calculating depth with mosdepth:
// (for GATK CallableLoci-like thresholding on DP)
params.mapq_thresh = "30"
//Quantile for maxDP calculation:
params.maxdp_quantile = "0.995"

//Default paths, globs, and regexes:
params.vcf_glob = "${projectDir}/byChrom/*.vcf.gz"
//Regex to pull out the chromosome:
params.vcfchr_regex = ~/_chr(\p{Alnum}+)$/
//For BAMs:
params.bam_glob = "${projectDir}/BAMs/*.ba{m,m.bai}"
//Regex to pull out the sample ID:
params.id_regex = ~/^(\p{Alnum})_MD_IR_recal/

//Reference-related parameters for the pipeline:
params.ref_prefix = "/gpfs/gibbs/pi/tucci/pfr8/refs"
params.ref = "${params.ref_prefix}/1kGP/hs37d5/hs37d5.fa"

//Set up the channel of VCFs
Channel
   .fromFilePairs(params.vcf_glob, size: 1, checkIfExists: true) { file -> (file.getSimpleName() =~ params.vcfchr_regex)[0][1] }
   .ifEmpty { error "Unable to find VCFs matching glob: ${params.vcf_glob}" }
   .tap { input_vcfs }
   .subscribe { println "Added chr${it[0]} (${it[1]}) to input_vcfs channels" }

Channel
   .fromFilePairs(params.vcf_glob+'.tbi', size: 1, checkIfExists: true) { file -> (file.getSimpleName() =~ params.vcfchr_regex)[0][1] }
   .ifEmpty { error "Unable to find VCF indices matching glob: ${params.vcf_glob}.tbi" }
   .tap { input_tbis }
   .subscribe { println "Added chr${it[0]} (${it[1]}) to input_tbis channels" }

bychrom_vcfs = input_vcfs.join(input_tbis, by: 0, failOnDuplicate: true, failOnMismatch: true)

//Set up the channel of BAMs for depth quantiles:
Channel
   .fromFilePairs(params.bam_glob, checkIfExists: true) { file -> (file.getSimpleName() =~ params.id_regex)[0][1] }
   .ifEmpty { error "Unable to find BAMs matching glob: ${params.bam_glob}" }
   .tap { bams_mosdepth }
   .subscribe { println "Added ${it[0]} to bams_mosdepth channels" }

//Set up the file channels for the ref and its various index components:
//Inspired by the IARC alignment-nf pipeline
//fai is generated by samtools faidx
ref = file(params.ref, checkIfExists: true)
ref_fai = file(params.ref+'.fai', checkIfExists: true)
//We also need a BED of the autosomes in the ref to calculate autosomal depth:
autosomes = file(params.ref_autosomes_bed, checkIfExists: true)
//And a BED of the PARs in the ref:
par = file(params.ref_par_bed, checkIfExists: true)

//Set up the file channels for the BEDs:
cpg = file(params.cpg_bed, checkIfExists: true)
segdup = file(params.segdup_bed, checkIfExists: true)
k35map = file(params.mappability_bed, checkIfExists: true)

//Archaic BEDs:
altainea = file(params.altainea_bed, checkIfExists: true)
vindijanea = file(params.vindijanea_bed, checkIfExists: true)
chagyrskayanea = file(params.chagyrskayanea_bed, checkIfExists: true)
altaiden = file(params.altaidenisova_bed, checkIfExists: true)

//Defaults for cpus, memory, and time for each process:
//Sample-dependent per-site filters:
params.persite_filters_cpus = 1
params.persite_filters_mem = 32
params.persite_filters_timeout = '24h'
//BED-based per-site filters:
params.bed_filters_cpus = 1
params.bed_filters_mem = 32
params.bed_filters_timeout = '24h'
//Fixed threshold genotype masks:
params.fixedthresh_masks_cpus = 1
params.fixedthresh_masks_mem = 32
params.fixedthresh_masks_timeout = '24h'
//Depth CDF from BAMs:
params.mosdepth_cpus = 1
params.mosdepth_mem = 4
params.mosdepth_timeout = '24h'
//maxDP genotype mask:
params.maxdp_bybin_cpus = 1
params.maxdp_bybin_mem = 32
params.maxdp_bybin_timeout = '24h'

process persite_filters {
   tag "chr${chrom}"

   cpus params.persite_filters_cpus
   memory { params.persite_filters_mem.plus(task.attempt.minus(1).multiply(32))+' GB' }
   time { task.attempt == 2 ? '72h' : params.persite_filters_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chrom), path(vcf), path(tbi) from bychrom_vcfs
   path ref
   path ref_fai

   output:
   tuple path("bcftools_filltags_chr${chrom}.stderr"), path("bcftools_filter_exchet_chr${chrom}.stderr"), path("bcftools_filter_hwe_chr${chrom}.stderr"), path("bcftools_filter_indelprox_chr${chrom}.stderr"), path("bcftools_filter_zeromissing_chr${chrom}.stderr"), path("bcftools_filter_missingness_chr${chrom}.stderr"), path("bcftools_filter_missingness_chr${chrom}.stdout") into hwe_indelprox_logs
   tuple val(chrom), path("${params.run_name}_chr${chrom}_sampledep_persite_filtered.vcf.gz"), path("${params.run_name}_chr${chrom}_sampledep_persite_filtered.vcf.gz.tbi") into persite_filtered_vcfs

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   bcftools +fill-tags !{vcf} -- -t ExcHet,HWE 2> bcftools_filltags_chr!{chrom}.stderr | \
      bcftools filter --threads !{task.cpus} -m+ -sExcHet!{params.exchet_thresh} -i 'MIN(INFO/ExcHet)>!{params.exchet_thresh}' - 2> bcftools_filter_exchet_chr!{chrom}.stderr | \
      bcftools filter --threads !{task.cpus} -m+ -sHWE!{params.hwe_thresh} -i 'MIN(INFO/HWE)>!{params.hwe_thresh}' - 2> bcftools_filter_hwe_chr!{chrom}.stderr | \
      bcftools filter --threads !{task.cpus} -m+ -g!{params.indelprox_thresh} -G!{params.indelprox_thresh} - 2> bcftools_filter_indelprox_chr!{chrom}.stderr | \
      bcftools filter --threads !{task.cpus} -m+ -sMissingness0 -i 'F_MISSING<=0.0' - 2> bcftools_filter_zeromissing_chr!{chrom}.stderr | \
      bcftools filter --threads !{task.cpus} -Oz -o !{params.run_name}_chr!{chrom}_sampledep_persite_filtered.vcf.gz -m+ -sMissingness!{params.missing_thresh} -i 'F_MISSING<=!{params.missing_thresh}' - 2> bcftools_filter_missingness_chr!{chrom}.stderr > bcftools_filter_missingness_chr!{chrom}.stdout
   tabix -f !{params.run_name}_chr!{chrom}_sampledep_persite_filtered.vcf.gz
   '''
}

process bed_filters {
   tag "chr${chrom}"

   cpus params.bed_filters_cpus
   memory { params.bed_filters_mem.plus(task.attempt.minus(1).multiply(32))+' GB' }
   time { task.attempt == 2 ? '72h' : params.bed_filters_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/filtered_VCFs", mode: 'copy', pattern: '*.vcf.g{z,z.tbi}'

   input:
   tuple val(chrom), path(vcf), path(tbi) from persite_filtered_vcfs
   path ref
   path ref_fai
   path cpg
   path segdup
   path par
   path k35map
   path altainea
   path vindijanea
   path chagyrskayanea
   path altaiden

   output:
   tuple path("bcftools_annotate_CpG_chr${chrom}.stderr"), path("bcftools_filter_CpG_chr${chrom}.stderr"), path("bcftools_annotate_SegDup_chr${chrom}.stderr"), path("bcftools_filter_SegDup_chr${chrom}.stderr"), path("bcftools_annotate_PAR_chr${chrom}.stderr"), path("bcftools_filter_PAR_chr${chrom}.stderr"), path("bcftools_annotate_AltaiNea_chr${chrom}.stderr"), path("bcftools_annotate_VindijaNea_chr${chrom}.stderr"), path("bcftools_annotate_ChagyrskayaNea_chr${chrom}.stderr"), path("bcftools_annotate_AltaiDenisova_chr${chrom}.stderr"), path("bcftools_filter_Archaics_chr${chrom}.stderr"), path("bcftools_annotate_Mappability50_chr${chrom}.stderr"), path("bcftools_filter_Mappability50_chr${chrom}.stderr"), path("bcftools_filter_Mappability50_chr${chrom}.stdout") into bed_filtered_logs
   tuple val(chrom), path("${params.run_name}_chr${chrom}_sampledep_and_bed_filtered.vcf.gz"), path("${params.run_name}_chr${chrom}_sampledep_and_bed_filtered.vcf.gz.tbi") into bed_filtered_vcfs

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   printf "##INFO=<ID=CpG,Number=0,Type=Flag,Description=\\"Overlaps CpG island\\">\\n" > CpG_header.txt
   printf "##INFO=<ID=SegDup,Number=0,Type=Flag,Description=\\"Overlaps genomicSuperDups region\\">\\n" > SegDup_header.txt
   printf "##INFO=<ID=PAR,Number=0,Type=Flag,Description=\\"Pseudo-autosomal regions of the sex chromosomes, called with incorrect ploidy in males\\">\\n" > PAR_header.txt
   printf "##INFO=<ID=AltaiNea,Number=0,Type=Flag,Description=\\"Found in Altai Neanderthal FilterBeds\\">\\n" > AltaiNea_header.txt
   printf "##INFO=<ID=VindijaNea,Number=0,Type=Flag,Description=\\"Found in Vindija Neanderthal FilterBeds\\">\\n" > VindijaNea_header.txt
   printf "##INFO=<ID=ChagyrskayaNea,Number=0,Type=Flag,Description=\\"Found in Chagyrskaya Neanderthal FilterBeds\\">\\n" > ChagyrskayaNea_header.txt
   printf "##INFO=<ID=AltaiDen,Number=0,Type=Flag,Description=\\"Found in Altai Denisovan FilterBeds\\">\\n" > AltaiDen_header.txt
   printf "##INFO=<ID=Mappability50,Number=0,Type=Flag,Description=\\"Overlaps the 35-mer mappability mask from Heng Li (50 percent 35-mer overlap allowing 1 mismatch)\\">\\n" > Mappability50_header.txt
   bcftools annotate -a !{cpg} -c CHROM,FROM,TO -mCpG -h CpG_header.txt !{vcf} 2> bcftools_annotate_CpG_chr!{chrom}.stderr | \
      bcftools filter -m+ -sCpG -e 'INFO/CpG=1' - 2> bcftools_filter_CpG_chr!{chrom}.stderr | \
      bcftools annotate -a !{segdup} -c CHROM,FROM,TO -mSegDup -h SegDup_header.txt - 2> bcftools_annotate_SegDup_chr!{chrom}.stderr | \
      bcftools filter -m+ -sSegDup -e 'INFO/SegDup=1' - 2> bcftools_filter_SegDup_chr!{chrom}.stderr | \
      bcftools annotate -a !{par} -c CHROM,FROM,TO -mPAR -h PAR_header.txt - 2> bcftools_annotate_PAR_chr!{chrom}.stderr | \
      bcftools filter -m+ -sPAR -e 'INFO/PAR=1' - 2> bcftools_filter_PAR_chr!{chrom}.stderr | \
      bcftools annotate -a !{altainea} -c CHROM,FROM,TO -mAltaiNea -h AltaiNea_header.txt - 2> bcftools_annotate_AltaiNea_chr!{chrom}.stderr | \
      bcftools annotate -a !{vindijanea} -c CHROM,FROM,TO -mVindijaNea -h VindijaNea_header.txt - 2> bcftools_annotate_VindijaNea_chr!{chrom}.stderr | \
      bcftools annotate -a !{chagyrskayanea} -c CHROM,FROM,TO -mChagyrskayaNea -h ChagyrskayaNea_header.txt - 2> bcftools_annotate_ChagyrskayaNea_chr!{chrom}.stderr | \
      bcftools annotate -a !{altaiden} -c CHROM,FROM,TO -mAltaiDen -h AltaiDen_header.txt - 2> bcftools_annotate_AltaiDenisova_chr!{chrom}.stderr | \
      bcftools filter -m+ -sArchaicMasked -i 'INFO/AltaiNea=1&&INFO/VindijaNea=1&&INFO/ChagyrskayaNea=1&&INFO/AltaiDen=1' - 2> bcftools_filter_Archaics_chr!{chrom}.stderr | \
      bcftools annotate -a !{k35map} -c CHROM,FROM,TO -mMappability50 -h Mappability50_header.txt - 2> bcftools_annotate_Mappability50_chr!{chrom}.stderr | \
      bcftools filter -Oz -o !{params.run_name}_chr!{chrom}_sampledep_and_bed_filtered.vcf.gz -m+ -sMappability50 -e 'INFO/Mappability50=1' - 2> bcftools_filter_Mappability50_chr!{chrom}.stderr > bcftools_filter_Mappability50_chr!{chrom}.stdout
   tabix -f !{params.run_name}_chr!{chrom}_sampledep_and_bed_filtered.vcf.gz
   '''
}

process fixedthresh_masks {
   tag "chr${chrom}"

   cpus params.fixedthresh_masks_cpus
   memory { params.fixedthresh_masks_mem.plus(task.attempt.minus(1).multiply(32))+' GB' }
   time { task.attempt == 2 ? '72h' : params.fixedthresh_masks_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chrom), path(vcf), path(tbi) from bed_filtered_vcfs
   path ref
   path ref_fai

   output:
   tuple path("bcftools_setGT_fixedthresh_chr${chrom}.stderr"), path("bcftools_setGT_fixedthresh_chr${chrom}.stdout") into fixedthresh_masks_logs
   tuple val(chrom), path("${params.run_name}_chr${chrom}_fixedthresh_masked.vcf.gz"), path("${params.run_name}_chr${chrom}_fixedthresh_masked.vcf.gz.tbi") into fixedthresh_masked_vcfs

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   bcftools +setGT -Oz -o !{params.run_name}_chr!{chrom}_fixedthresh_masked.vcf.gz !{vcf} -- -t q -n . -i 'FMT/DP[*]<!{params.mindp_thresh}|FMT/GQ[*]<!{params.mingq_thresh}' 2> bcftools_setGT_fixedthresh_chr!{chrom}.stderr > bcftools_setGT_fixedthresh_chr!{chrom}.stdout
   tabix -f !{params.run_name}_chr!{chrom}_fixedthresh_masked.vcf.gz
   '''
}

process mosdepth {
   tag "${sampleid}"

   cpus params.mosdepth_cpus
   memory { params.mosdepth_mem.plus(task.attempt.minus(1).multiply(4))+' GB' }
   time { task.attempt == 2 ? '72h' : params.mosdepth_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/stats", mode: 'copy', pattern: '*.txt'

   input:
   tuple val(sampleid), path(bambai) from bams_mosdepth
   path ref
   path ref_fai
   path autosomes

   output:
   tuple path("mosdepth_${sampleid}.stderr"), path("mosdepth_${sampleid}.stdout") into mosdepth_logs
   tuple path("${sampleid}.mosdepth.global.dist.txt"), path("${sampleid}.mosdepth.region.dist.txt"), path("${sampleid}.mosdepth.summary.txt") into mosdepth_stats
   stdout into mosdepth_maxdps

   shell:
   '''
   module load !{params.mod_mosdepth}
   MOSDEPTH_PRECISION=3 mosdepth -n --fast-mode --by !{autosomes} --mapq !{params.mapq_thresh} !{sampleid} !{bambai[0]} 2> mosdepth_!{sampleid}.stderr > mosdepth_!{sampleid}.stdout
   awk 'BEGIN{FS="\t";OFS=FS;maxdpq=1-!{params.maxdp_quantile};}$1=="total"&&$3<=maxdpq{dpthresh=$2;}END{print "!{sampleid}", dpthresh;}' !{sampleid}.mosdepth.global.dist.txt
   '''
}

process maxdp_bybin {
   tag "chr${chrom}"

   cpus params.maxdp_bybin_cpus
   memory { params.maxdp_bybin_mem.plus(task.attempt.minus(1).multiply(32))+' GB' }
   time { task.attempt == 2 ? '72h' : params.maxdp_bybin_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.{tsv,pdf}'
   publishDir path: "${params.output_dir}/filtered_VCFs", mode: 'copy', pattern: '*.vcf.g{z,z.tbi}'

   input:
   tuple val(chrom), path(vcf), path(tbi), path(maxdps) from fixedthresh_masked_vcfs.combine(mosdepth_maxdps.collectFile(name: 'mosdepth_maxdps.tsv'))
   path ref
   path ref_fai

   output:
   tuple path("bcftools_setGT_maxDP_chr${chrom}.stderr"), path("bcftools_setGT_maxDP_chr${chrom}.stdout") into maxdp_bybin_logs
   tuple path(maxdps), path("maxdp_bins.tsv"), path("maxDP_clustering.pdf") into maxdp_bybin_clustering
   tuple val(chrom), path("${params.run_name}_chr${chrom}_allmasks.vcf.gz"), path("${params.run_name}_chr${chrom}_allmasks.vcf.gz.tbi") into maxdp_bybin_vcfs

   shell:
   '''
   module load !{params.mod_R}
   !{projectDir}/binMaxDP.R !{maxdps} maxdp_bins.tsv
   module unload !{params.mod_R}
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   maxdp_thresh_str=$(awk 'BEGIN{FS="\t";}NR==1{printf "FMT/DP[@%s]>%s", $1, $2;}NR>1{printf "|FMT/DP[@%s]>%s", $1, $2;}' maxdp_bins.tsv)
   bcftools +setGT -Oz -o !{params.run_name}_chr!{chrom}_allmasks.vcf.gz !{vcf} -- -t q -n . -i "${maxdp_thresh_str}" 2> bcftools_setGT_maxDP_chr!{chrom}.stderr > bcftools_setGT_maxDP_chr!{chrom}.stdout
   tabix -f !{params.run_name}_chr!{chrom}_allmasks.vcf.gz
   '''
}
