#!/usr/bin/env nextflow
/* Pipeline to infer two-population demographic histories and    *
 *  splits with MSMC2 and MSMC-IM                                *
 * Core steps:                                                   *
 *  Extraction of target samples from main VCF ->                *
 *  Composing per-sample masks from mosdepth's quantized BEDs -> *
 *  Filter VCFs for only mono- or biallelic SNPs ->              *
 *  generate_multihetsep.py to make MSMC2 inputs ->              *
 *  msmc2 and MSMC-IM.py on each pop pair                        */

nextflow.enable.dsl=2

//Default paths, globs, and regexes:
//Input VCFs:
params.vcf_glob = "${projectDir}/VCFs/*.vcf.gz"
//Regex for extracting chromosome from VCF filename:
params.vcf_regex = ~/_chr(\p{Alnum}+)$/
//Glob for the per-individual BAMs and their indices:
params.bam_glob = "${projectDir}/BAMs/*_MD_IR_recal_filtered.ba{m,m.bai}"
//Regex for parsing the sample ID out of the BAM filename:
params.bam_regex = ~/^(.+)_MD_IR_recal_filtered$/
//Glob for the per-individual autosomal depth distributions from mosdepth
// generated by filter_VCF.nf:
//params.depth_dist_glob = "${projectDir}/depthdists/*.mosdepth.global.dist.txt"
//Regex for parsing the sample ID out of the depth dist filename:
//params.depth_regex = ~/^(.+)$/
//Glob for the ref mappability filters:
params.mappability_glob = "${projectDir}/mappability/*.bed"
//Regex for parsing the chromosome from mappability filter filename:
params.mappability_regex = ~/^hs37d5_chr(\p{Alnum}+)$/
//Sample ID column name in metadata file:
params.id_colname = "SampleID"
//Target group column name:
params.msmc2_target_colname = "AnalysisGroup"

//Reference-related parameters for the pipeline:
params.ref_prefix = "/gpfs/gibbs/pi/tucci/pfr8/refs"
params.ref = "${params.ref_prefix}/1kGP/hs37d5/hs37d5.fa"
params.autosomes = "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22"

//Default parameter values:
//Filters to apply to the input VCF:
params.includestr = ""
//MAPQ threshold for calculating depth with mosdepth for GATK CallableLoci-like thresholding on DP:
params.mapq_thresh = "30"
//Lower and upper bounds for depth when making the per-sample masks:
params.mindp = "10"
params.maxdp_quantile = "0.995"
//Mutation rate for MSMC2:
params.mutation_rate = '1.25e-8'
//Default PRNG seed for selecting individuals:
params.prng_seed = "42"
//Number of samples to use per population for MSMC2:
params.msmc2_num_samples = 2
params.msmc2_num_haplotypes = params.msmc2_num_samples.multiply(2)
//Time pattern string for MSMC2:
//Default is 1*2+25*1+1*2+1*3
params.msmc2_time_pattern = '1*2+25*1+1*2+1*3'
//MSMC-IM parameters:
params.beta1 = '1e-8'
params.beta2 = '1e-6'
params.betas = "${params.beta1},${params.beta2}"

process vcf_split {
   tag "${pop} chr${chrom}"

   cpus params.vcf_split_cpus
   memory { params.vcf_split_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt >= 2 ? '24h' : params.vcf_split_timeout }
   queue params.vcf_split_queue
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(pop), val(chrom), path(vcf), path(tbi)
   path(metadata)

   output:
   tuple val(pop), val(chrom), path("bcftools_view_subsample_${pop}_chr${chrom}.stderr"), path("bcftools_view_subsample_${pop}_chr${chrom}.stdout"), path("bcftools_split_${pop}_chr${chrom}.stderr"), path("bcftools_split_${pop}_chr${chrom}.stdout"), emit: logs
   path "chr${chrom}_*.vcf.gz", emit: vcfs
   path "chr${chrom}_*.vcf.gz.tbi", emit: tbis
   tuple val(pop), path("${pop}_samples.tsv"), emit: tsv

   shell:
   '''
   module load !{params.mod_htslib}
   module load !{params.mod_bcftools}
   !{projectDir}/HumanPopGenScripts/selectSubsamples.awk -v "idcol=!{params.id_colname}" -v "samplecol=!{params.msmc2_target_colname}" -v "subsample=!{pop}" -v "sizes=!{params.msmc2_num_samples}" -v "seed=!{params.prng_seed}" !{metadata} > !{pop}_samples.tsv
   bcftools view -S !{pop}_samples.tsv -Oz -o !{pop}_chr!{chrom}.vcf.gz !{vcf} 2> bcftools_view_subsample_!{pop}_chr!{chrom}.stderr > bcftools_view_subsample_!{pop}_chr!{chrom}.stdout
   tabix -f !{pop}_chr!{chrom}.vcf.gz
   mkdir !{pop}
   bcftools +split -Oz -o !{pop}/chr!{chrom} -S !{pop}_samples.tsv !{vcf} 2> bcftools_split_!{pop}_chr!{chrom}.stderr > bcftools_split_!{pop}_chr!{chrom}.stdout
   for i in !{pop}/chr!{chrom}/*.vcf.gz; do
      fn=$(basename ${i});
      ln -s ${i} chr!{chrom}_${fn};
      tabix -f chr!{chrom}_${fn};
   done
   '''
}

process mosdepth {
   tag "${sample}"

   cpus params.mosdepth_cpus
   memory { params.mosdepth_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt >= 2 ? '24h' : params.mosdepth_timeout }
   queue params.mosdepth_queue
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/stats", mode: 'copy', pattern: '*.mosdepth.*'

   input:
//   tuple val(sample), path("${sample}.mosdepth.global.dist.txt"), path(bambai)
   tuple val(sample), path(bambai)
   path(autosomes)

   output:
   tuple val(sample), path("mosdepth_${sample}.stderr"), path("mosdepth_${sample}.stdout"), path("mosdepth_quantize_${sample}.stderr"), path("mosdepth_quantize_${sample}.stdout"), emit: logs
   tuple val(sample), path("${sample}.quantized.bed.gz"), emit: bed
   tuple val(sample), path("${sample}.mosdepth.global.dist.txt"), path("${sample}.mosdepth.region.dist.txt"), path("${sample}.mosdepth.summary.txt"), emit: stats

   shell:
   '''
   module load !{params.mod_mosdepth}
   MOSDEPTH_PRECISION=3 mosdepth -n --fast-mode --by !{autosomes} --mapq !{params.mapq_thresh} !{sample} !{bambai[0]} 2> mosdepth_!{sample}.stderr > mosdepth_!{sample}.stdout
   maxdp=$(!{projectDir}/HumanPopGenScripts/MSMC2/determineMaxDPthresh.awk -v "quantile=!{params.maxdp_quantile}" !{sample}.mosdepth.global.dist.txt)
   if [[ "${maxdp}" -le "!{params.mindp}" ]]; then
      echo "Error: Calculated max DP for !{sample} is less than !{params.mindp}, cannot proceed." > "/dev/stderr"
      exit 2
   fi
   MOSDEPTH_Q0=NO_DEPTH MOSDEPTH_Q1=LOW_DEPTH MOSDEPTH_Q2=CALLABLE MOSDEPTH_Q3=HIGH_DEPTH mosdepth -n --fast-mode --mapq !{params.mapq_thresh} --quantize 0:1:!{params.mindp}:${maxdp}: !{sample} !{bambai[0]} 2> mosdepth_quantize_!{sample}.stderr > mosdepth_quantize_!{sample}.stdout
   '''
}

process sample_mask {
   tag "${sample}"

   cpus params.sample_mask_cpus
   memory { params.sample_mask_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt >= 2 ? '24h' : params.sample_mask_timeout }
   queue params.sample_mask_queue
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(sample), path(vcfs), path(tbis), path("${sample}.quantized.bed.gz")
   val(autosome_list)
   val(autosome_num_list)

   output:
   tuple val(sample), path("bcftools_query_missing_${sample}_chr*.stderr"), path("bedtools_merge_missing_${sample}_chr*.stderr"), path("bedtools_subtract_callable_${sample}_chr*.stderr"), emit: logs
   tuple val(sample), path("${sample}_chr*.callable.bed.gz"), emit: callablebed

   shell:
   '''
   module load !{params.mod_bedtools}
   module load !{params.mod_bcftools}
   #Simple handling of refs with "chr" prefix like GRCh38:
   declare -A chrom_map
   for c in {!{autosome_list}};
      do
      cn=${c#chr};
      chrom_map[${cn}]=${c};
   done
   #Loop over the chromosomes, since this step is very fast (< 1 minute per chromosome):
   for cn in {!{autosome_num_list}};
      do
      c=${chrom_map[${cn}]};
      gzip -dc !{sample}.quantized.bed.gz | \\
         !{projectDir}/HumanPopGenScripts/MSMC2/callablePerChrom.awk -v "chrom=${c}" | \\
         bedtools subtract -a - -b <(bcftools query -i 'GT="mis"' -f '%CHROM\\t%POS0\\t%POS\\n' chr${cn}_!{sample}.vcf.gz 2> bcftools_query_missing_!{sample}_chr${cn}.stderr | bedtools merge -i - 2> bedtools_merge_missing_!{sample}_chr${cn}.stderr) 2> bedtools_subtract_callable_!{sample}_chr${cn}.stderr | \\
         gzip -9 > !{sample}_chr${cn}.callable.bed.gz
   done
   '''
}

process vcf_filter {
   tag "${sample}"

   cpus params.vcf_filter_cpus
   memory { params.vcf_filter_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt >= 2 ? '24h' : params.vcf_filter_timeout }
   queue params.vcf_filter_queue
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(sample), path(vcfs), path(tbis)
   val(autosome_num_list)

   output:
   tuple val(sample), path("bcftools_view_monobiallelic_nomissinggeno_${sample}_chr*.stderr"), path("bcftools_view_monobiallelic_nomissinggeno_${sample}_chr*.stdout"), emit: logs
   tuple val(sample), path("${sample}_chr*_forMSMC2.vcf.gz"), emit: vcf

   shell:
   '''
   module load !{params.mod_bcftools}
   #Loop over the chromosomes, since this step is very fast (< 2 minutes per chromosome):
   for cn in {!{autosome_num_list}};
      do
      bcftools view -M2 -v snps -g ^miss -Oz -o !{sample}_chr${cn}_forMSMC2.vcf.gz chr${cn}_!{sample}.vcf.gz 2> bcftools_view_monobiallelic_nomissinggeno_!{sample}_chr${cn}.stderr > bcftools_view_monobiallelic_nomissinggeno_!{sample}_chr${cn}.stdout
   done
   '''
}

process msmc2_ccr_prep {
   tag "${qpop} ${tpop} chr${chrom}"

   cpus params.msmc2_ccr_prep_cpus
   memory { params.msmc2_ccr_prep_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt >= 2 ? '24h' : params.msmc2_ccr_prep_timeout }
   queue params.msmc2_ccr_prep_queue
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chrom), val(qpop), val(tpop), path("${qpop}_samples.tsv"), path("${tpop}_samples.tsv"), path(qbeds), path(qvcfs), path(tbeds), path(tvcfs), path(reffilter)

   output:
   tuple val(qpop), val(tpop), val(chrom), path("generate_multihetsep_${qpop}_${tpop}_chr${chrom}.stderr"), emit: logs
   tuple val(qpop), val(tpop), path("${qpop}_${tpop}_chr${chrom}_multihetsep.txt"), emit: multihetsep

   shell:
   '''
   module load !{params.mod_msmctools}
   #Set up the mask and VCF argument lists for generate_multihetsep.py:
   samplemasks="";
   samplevcfs="";
   while read sampleid;
      do
      samplemasks="${samplemasks} --mask=${sampleid}_chr!{chrom}.callable.bed.gz";
      samplevcfs="${samplevcfs} ${sampleid}_chr!{chrom}_forMSMC2.vcf.gz";
   done < <(cat !{qpop}_samples.tsv !{tpop}_samples.tsv)
   #Run generate_multihetsep.py:
   /usr/bin/time -v generate_multihetsep.py --mask=!{reffilter} ${samplemasks} ${samplevcfs} 2> generate_multihetsep_!{qpop}_!{tpop}_chr!{chrom}.stderr > !{qpop}_!{tpop}_chr!{chrom}_multihetsep.txt
   '''
}

process msmc2_ccr {
   tag "${qpop} ${tpop}"

   cpus params.msmc2_ccr_cpus
   memory { params.msmc2_ccr_mem.plus(task.attempt.minus(1).multiply(32))+' GB' }
   time { task.attempt >= 2 ? '72h' : params.msmc2_ccr_timeout }
   queue { task.attempt >= 2 ? params.msmc2_ccr_long_queue : params.msmc2_ccr_queue }
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/MSMC2", mode: 'copy', pattern: '*.txt'

   input:
   tuple val(qpop), val(tpop), path(multihetseps)

   output:
   tuple val(qpop), val(tpop), path("msmc2_${qpop}_${tpop}_${qpop}_n${params.msmc2_num_haplotypes}.stderr"), path("msmc2_${qpop}_${tpop}_${qpop}_n${params.msmc2_num_haplotypes}.stdout"), path("msmc2_${qpop}_${tpop}_${tpop}_n${params.msmc2_num_haplotypes}.stderr"), path("msmc2_${qpop}_${tpop}_${tpop}_n${params.msmc2_num_haplotypes}.stdout"), path("msmc2_${qpop}_${tpop}_crossCoalescence_n${params.msmc2_num_haplotypes}.stderr"), path("msmc2_${qpop}_${tpop}_crossCoalescence_n${params.msmc2_num_haplotypes}.stdout"), path("combineCrossCoal_${qpop}_${tpop}_n${params.msmc2_num_haplotypes}.stderr"), emit: logs
   tuple val(qpop), val(tpop), path("${qpop}_${tpop}_n${params.msmc2_num_haplotypes}_combined.msmc2.final.txt"), emit: combined
   tuple val(qpop), val(tpop), path("${qpop}_${tpop}_${qpop}_n${params.msmc2_num_haplotypes}.msmc2.loop.txt"), path("${qpop}_${tpop}_${qpop}_n${params.msmc2_num_haplotypes}.msmc2.final.txt"), path("${qpop}_${tpop}_${tpop}_n${params.msmc2_num_haplotypes}.msmc2.loop.txt"), path("${qpop}_${tpop}_${tpop}_n${params.msmc2_num_haplotypes}.msmc2.final.txt"), path("${qpop}_${tpop}_crossCoalescence_n${params.msmc2_num_haplotypes}.msmc2.loop.txt"), path("${qpop}_${tpop}_crossCoalescence_n${params.msmc2_num_haplotypes}.msmc2.final.txt"), emit: parts

   shell:
   '''
   module load !{params.mod_msmc2}
   module load !{params.mod_msmctools}
   #First pop alone:
   haplist=$(seq -s, 0 $((!{params.msmc2_num_haplotypes}-1)))
   echo "Haplotype pair list for !{qpop} MSMC2: ${haplist}"
   /usr/bin/time -v msmc2 -t !{task.cpus} -p "!{params.msmc2_time_pattern}" --skipAmbiguous -o !{qpop}_!{tpop}_!{qpop}_n!{params.msmc2_num_haplotypes}.msmc2 -I ${haplist} !{multihetseps} 2> msmc2_!{qpop}_!{tpop}_!{qpop}_n!{params.msmc2_num_haplotypes}.stderr > msmc2_!{qpop}_!{tpop}_!{qpop}_n!{params.msmc2_num_haplotypes}.stdout
   #Second pop alone:
   haplist=$(seq -s, !{params.msmc2_num_haplotypes} $((2*!{params.msmc2_num_haplotypes}-1)))
   echo "Haplotype pair list for !{tpop} MSMC2: ${haplist}"
   /usr/bin/time -v msmc2 -t !{task.cpus} -p "!{params.msmc2_time_pattern}" --skipAmbiguous -o !{qpop}_!{tpop}_!{tpop}_n!{params.msmc2_num_haplotypes}.msmc2 -I ${haplist} !{multihetseps} 2> msmc2_!{qpop}_!{tpop}_!{tpop}_n!{params.msmc2_num_haplotypes}.stderr > msmc2_!{qpop}_!{tpop}_!{tpop}_n!{params.msmc2_num_haplotypes}.stdout
   #Cross-coalescence:
   haplist=""
   amax=$((!{params.msmc2_num_haplotypes}-1))
   bmax=$((2*!{params.msmc2_num_haplotypes}-1))
   a=0
   while [[ "${a}" -le "${amax}" ]];
      do
      b=!{params.msmc2_num_haplotypes}
      while [[ "${b}" -le "${bmax}" ]];
         do
         haplist="${haplist},${a}-${b}"
         b=$((b+1))
      done
      a=$((a+1))
   done
   haplist=${haplist:1}
   echo "Haplotype pair list for !{qpop}-!{tpop} cross-coalescence MSMC2: ${haplist}"
   /usr/bin/time -v msmc2 -t !{task.cpus} -p "!{params.msmc2_time_pattern}" --skipAmbiguous -o !{qpop}_!{tpop}_crossCoalescence_n!{params.msmc2_num_haplotypes}.msmc2 -I ${haplist} !{multihetseps} 2> msmc2_!{qpop}_!{tpop}_crossCoalescence_n!{params.msmc2_num_haplotypes}.stderr > msmc2_!{qpop}_!{tpop}_crossCoalescence_n!{params.msmc2_num_haplotypes}.stdout
   #Interpolate the results across runs:
   /usr/bin/time -v combineCrossCoal.py !{qpop}_!{tpop}_crossCoalescence_n!{params.msmc2_num_haplotypes}.msmc2.final.txt !{qpop}_!{tpop}_!{qpop}_n!{params.msmc2_num_haplotypes}.msmc2.final.txt !{qpop}_!{tpop}_!{tpop}_n!{params.msmc2_num_haplotypes}.msmc2.final.txt 2> combineCrossCoal_!{qpop}_!{tpop}_n!{params.msmc2_num_haplotypes}.stderr > !{qpop}_!{tpop}_n!{params.msmc2_num_haplotypes}_combined.msmc2.final.txt
   '''
}

process msmcim {
   tag "${qpop} ${tpop}"

   cpus params.msmc_im_cpus
   memory { params.msmc_im_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt >= 2 ? '24h' : params.msmc_im_timeout }
   queue params.msmc_im_queue
   errorStrategy { task.exitStatus in 134..140 ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.log'
   publishDir path: "${params.output_dir}/MSMC-IM", mode: 'copy', pattern: '*.txt'
   publishDir path: "${params.output_dir}/MSMC-IM", mode: 'copy', pattern: '*.pdf'

   input:
   tuple val(qpop), val(tpop), path(combined)

   output:
   tuple val(qpop), val(tpop), path("MSMC-IM_${qpop}_${tpop}_n${params.msmc2_num_haplotypes}.stderr"), path("MSMC-IM_${qpop}_${tpop}_n${params.msmc2_num_haplotypes}.stdout"), emit: logs
   tuple val(qpop), val(tpop), path("${qpop}_${tpop}_n${params.msmc2_num_haplotypes}.*.MSMC_IM.estimates.txt"), path("${qpop}_${tpop}_n${params.msmc2_num_haplotypes}.*.MSMC_IM.fittingdetails.txt"), path("${qpop}_${tpop}_n${params.msmc2_num_haplotypes}.*.MSMC_IM.fittingdetails.xlog.pdf"), emit: fits

   shell:
   '''
   module load !{params.mod_msmc_im}
   /usr/bin/time -v MSMC_IM.py -mu !{params.mutation_rate} -p "!{params.msmc2_time_pattern}" -beta "!{params.betas}" --printfittingdetails --plotfittingdetails --xlog -o ./!{qpop}_!{tpop}_n!{params.msmc2_num_haplotypes} !{combined} 2> MSMC-IM_!{qpop}_!{tpop}_n!{params.msmc2_num_haplotypes}.stderr > MSMC-IM_!{qpop}_!{tpop}_n!{params.msmc2_num_haplotypes}.stdout
   '''
}

workflow {
   //Detection mechanism for "chr" prefixes of autosomes:
   has_chr_prefix = params.autosomes.count('chr') > 0
   autosome_list = params.autosomes
   autosome_num_list = has_chr_prefix ? params.autosomes.replaceAll('chr', '') : autosome_list
   num_autosomes = autosome_num_list.tokenize(',').size()
   //We also need a BED of the autosomes in the ref to calculate autosomal depth:
   autosomes = file(params.ref_autosomes_bed, checkIfExists: true)
   //Channel of per-chromosome VCFs and indices:
   Channel
      .fromPath(params.vcf_glob, checkIfExists: true)
      .ifEmpty { error "Unable to find VCFs matching glob: ${params.vcf_glob}" }
      .map { a -> [ (a.getSimpleName() =~ params.vcf_regex)[0][1], a ] }
      .ifEmpty { error "Regex failed to extract chromosome ID from VCF: ${params.vcf_regex}" }
      .tap { vcfs_only }
      .subscribe { println "Added ${it[1]} to vcfs_only channel" }
   Channel
      .fromPath(params.vcf_glob+'.tbi', checkIfExists: true)
      .ifEmpty { error "Unable to find VCF indices matching glob: ${params.vcf_glob}.tbi" }
      .map { a -> [ (a.getSimpleName() =~ params.vcf_regex)[0][1], a ] }
      .ifEmpty { error "Regex failed to extract chromosome ID from VCF index: ${params.vcf_regex}" }
      .tap { tbis_only }
      .subscribe { println "Added ${it[1]} to tbis_only channel" }
   vcfs = vcfs_only
      .join(tbis_only, by: 0, failOnDuplicate: true, failOnMismatch: true)
      .filter({ autosome_num_list.tokenize(',').contains(it[0]) })

   //Channel for population pairs to run:
   Channel
      .fromPath(params.msmc2_poppairs_file, checkIfExists: true)
      .ifEmpty { error "Unable to find population pairs file for MSMC2: ${params.msmc2_poppairs_file}" }
      .splitCsv(sep: "\t")
      .map { [it[0], it[1]] }
      .tap { poppairs }
      .tap { pops_formap }
      .tap { pops_forsplit }
      .subscribe { println "Added ${it[0]},${it[1]} to poppairs channel" }
   //Channels for filtering samples by population:
   Channel
      .fromPath(params.metadata_file, checkIfExists: true)
      .ifEmpty { error "Unable to find metadata file: ${params.metadata_file}" }
      .splitCsv(sep: "\t", header: true)
      .map { [ it[params.msmc2_target_colname], it[params.id_colname] ] }
      .combine(pops_formap.flatten().unique(), by: 0)
      .tap { samples_forbamfiltering }
      .tap { samples_fordistfiltering }
      .map { [ it[1], it[0] ] }
      .tap { pop_map }
      .subscribe { "Added ${it[0]}->${it[1]} to pop_map channel" }
   //Value channel for selecting samples from each population:
   metadata = file(params.metadata_file, checkIfExists: true)
   
   //Channels for the per-sample BAMs, indices, and mosdepth *.global.dist.txt files from filter_VCF.nf:
   Channel
      .fromFilePairs(params.bam_glob, checkIfExists: true) { file -> (file.getSimpleName() =~ params.bam_regex)[0][1] }
      .ifEmpty { error "Unable to find BAMs matching glob: ${params.bam_glob}" }
      .combine(samples_forbamfiltering.map({ it[1] }), by: 0)
      .tap { bams }
      .subscribe { "Added ${it[0]} to bams channel" }
/*   Channel
      .fromPath(params.depth_dist_glob, checkIfExists: true)
      .ifEmpty { error "Unable to find depth distribution files matching glob: ${params.depth_dist_glob}" }
      .map { a -> [ (a.getSimpleName() =~ params.depth_regex)[0][1], a ] }
      .ifEmpty { error "Regex failed to extract sample ID from depth distribution filename: ${params.depth_regex}" }
      .combine(samples_fordistfiltering.map({ it[1] }), by: 0)
      .tap { depth_dists }
      .subscribe { println "Added ${it[0]} (${it[1]}) to depth_dists channel" }*/

   //Channel for the per-chromosome ref-specific mappability masks:
   Channel
      .fromPath(params.mappability_glob, checkIfExists: true)
      .ifEmpty { error "Unable to find ref-specific mappability masks matching glob: ${params.mappability_glob}" }
      .map { a -> [ (a.getSimpleName() =~ params.mappability_regex)[0][1], a ] }
      .ifEmpty { error "Regex failed to extract chromosome from mappability mask filename: ${params.mappability_regex}" }
      .tap { mappability_masks }
      .subscribe { println "Added ${it[1]} to mappability_masks channel" }

   //Pick individuals and split VCFs:
   vcf_split_input = pops_forsplit
      .flatten()
      .unique()
      .combine(vcfs)
   vcf_split(vcf_split_input, metadata)
   //Set up channel with VCFs and TBIs:
   splitvcf_regex = ~/^chr(\p{Alnum}+)_(.+)$/
   perchrom_vcfs = vcf_split.out.vcfs
      .flatten()
      .map { a -> [ (a.getSimpleName() =~ splitvcf_regex)[0][2], (a.getSimpleName() =~ splitvcf_regex)[0][1], a ] }
      .ifEmpty { error "Regex failed to extract sample ID and chromosome from split VCF: ${splitvcf_regex}" }
   perchrom_tbis = vcf_split.out.tbis
      .flatten()
      .map { a -> [ (a.getSimpleName() =~ splitvcf_regex)[0][2], (a.getSimpleName() =~ splitvcf_regex)[0][1], a ] }
      .ifEmpty { error "Regex failed to extract sample ID and chromosome from split TBI: ${splitvcf_regex}" }
      .tap { tbis_forsampleselection }
   split_vcfs_mask = perchrom_vcfs
      .join(perchrom_tbis, by: [0,1], failOnDuplicate: true, failOnMismatch: true)
      .map { sample, chrom, vcf, tbi -> [ sample, vcf, tbi ] }
      .groupTuple(by: 0)
      .tap { split_vcfs_filter }
   //Sample list of selected individuals:
   samples_to_keep = tbis_forsampleselection
      .map { it[0] }
      .unique()

   //Generate per-sample callable masks:
   //Run the mosdepth equivalent of GATK CallableLoci:
//   mosdepth_inputs = depth_dists
//      .join(bams, by: 0, failOnDuplicate: true, failOnMismatch: true)
   mosdepth_inputs = bams
      .combine(samples_to_keep, by: 0)
   mosdepth(mosdepth_inputs, autosomes)
   //Now generate the filter masks using callable loci and excluding sites with missing genotypes:
   //The inputs are per sample, not per (sample,chrom) tuple.
   sample_mask(split_vcfs_mask.combine(mosdepth.out.bed, by: 0), autosome_list, autosome_num_list)

   //Filter VCFs to exclude sites missing genotypes and only retain mono- or biallelic SNPs:
   vcf_filter(split_vcfs_filter, autosome_num_list)

   //Prepare inputs for MSMC2:
   bed_regex = ~/^(.+)_chr(\p{Alnum}+)$/
   vcf_regex = ~/^(.+)_chr(\p{Alnum}+)_forMSMC2$/
   callable_beds = sample_mask.out.callablebed
      .transpose()
      .map { sample, bed -> [ sample, (bed.getSimpleName() =~ bed_regex)[0][2], bed ] }
   filtered_vcfs = vcf_filter.out.vcf
      .transpose()
      .map { sample, vcf -> [ sample, (vcf.getSimpleName() =~ vcf_regex)[0][2], vcf ] }
   bed_vcf_byqpop = pop_map
      .combine(callable_beds.join(filtered_vcfs, by: [0,1], failOnDuplicate: true, failOnMismatch: true), by: 0)
      .map { sample, pop, chrom, bed, vcf -> [ pop, chrom, bed, vcf ] }
      .groupTuple(by: [0,1])
      .tap { bed_vcf_bytpop }
   qpop_samples = vcf_split.out.tsv
      .unique { it[0] }
      .tap { tpop_samples }
   sample_lists = poppairs
      .combine(qpop_samples, by: 0)
      .map { qpop, tpop, qsam -> [ tpop, qpop, qsam ] }
      .combine(tpop_samples, by: 0)
      .map { tpop, qpop, qsam, tsam -> [ qpop, tpop, qsam, tsam ] }
   msmc2_ccr_prep_inputs = sample_lists
      .combine(bed_vcf_byqpop, by: 0)
      .map { qpop, tpop, qsam, tsam, chrom, qbeds, qvcfs -> [ tpop, chrom, qpop, qsam, tsam, qbeds, qvcfs ] }
      .combine(bed_vcf_bytpop, by: [0,1])
      .map { tpop, chrom, qpop, qsam, tsam, qbeds, qvcfs, tbeds, tvcfs -> [ chrom, qpop, tpop, qsam, tsam, qbeds, qvcfs, tbeds, tvcfs ] }
      .combine(mappability_masks, by: 0)
   msmc2_ccr_prep(msmc2_ccr_prep_inputs)

   //Run MSMC2 for two populations:
   msmc2_ccr_inputs = msmc2_ccr_prep.out.multihetsep
      .groupTuple(by: [0,1], size: num_autosomes)
   msmc2_ccr(msmc2_ccr_inputs)

   //Run MSMC-IM:
   msmcim(msmc2_ccr.out.combined)
}
