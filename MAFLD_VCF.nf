#!/usr/bin/env nextflow
/* Pipeline for MAF filtering and LD pruning VCFs                        *
 * Steps:                                                                *
 *  Per-superpopulation MAF annotation (bcftools +fill-tags) ->          *
 *  User-defined MAF filter (bcftools view -i) ->                        *
 *  VCF to pgen per chromosome, bSNPs only (--make-pgen vzs) ->          *
 *  Merge autosomal pgens (--pmerge-list --pmerge-output-vzs) ->         *
 *  User-defined PLINK LD pruning (--indep-pairwise) ->                  *
 *  Extract pruned SNPs as BED/BIM/FAM (--extract --make-bed)            */

//Minimal filters expression:
//VQSR passing and 5% missingness after	applying the DP<10, DP>99.5th percentile, and GQ<30 genotype masks
params.minimal_filter_str = 'FILTER!~"Missingness0.05"&&FILTER!~"LowQual"&&FILTER!~"VQSRTrancheSNP99.90to100.00+"&&FILTER!~"VQSRTrancheSNP99.90to100.00"&&FILTER!~"VQSRTrancheINDEL99.90to100.00+"&&FILTER!~"VQSRTrancheINDEL99.90to100.00"&&FILTER!~"VQSRTrancheINDEL99.50to99.90"&&FILTER!~"VQSRTrancheINDEL99.00to99.50"'
//MAF filter expression:
params.maf_filter_str = "(MAF_AMR+MAF_EUR+MAF_AFR+MAF_MDE+MAF_CSA+MAF_EAS+MAF_ISEA+MAF_OCN)/8>=0.01"
//LD pruning parameters:
params.ld_pruning_algo = "--indep-pairwise"
params.ld_pruning_params = "50 5 0.5"

//Default paths, globs, and regexes:
params.vcf_glob = "${projectDir}/input_VCFs/*.vcf.gz"
//Regex to pull out the chromosome:
params.vcfchr_regex = ~/_chr(\p{Alnum}+)/

//Reference-related parameters for the pipeline:
params.ref_prefix = "/gpfs/gibbs/pi/tucci/pfr8/refs"
params.ref = "${params.ref_prefix}/1kGP/hs37d5/hs37d5.fa"

//Set up the channel of VCFs
Channel
   .fromFilePairs(params.vcf_glob, size: 1, checkIfExists: true) { file -> (file.getSimpleName() =~ params.vcfchr_regex)[0][1] }
   .ifEmpty { error "Unable to find VCFs matching glob: ${params.vcf_glob}" }
   .tap { input_vcfs }
   .subscribe { println "Added chr${it[0]} (${it[1]}) to input_vcfs channels" }

Channel
   .fromFilePairs(params.vcf_glob+'.tbi', size: 1, checkIfExists: true) { file -> (file.getSimpleName() =~ params.vcfchr_regex)[0][1] }
   .ifEmpty { error "Unable to find VCF indices matching glob: ${params.vcf_glob}.tbi" }
   .tap { input_tbis }
   .subscribe { println "Added chr${it[0]} (${it[1]}) to input_tbis channels" }

//Only retain the autosomes
bychrom_vcfs = input_vcfs.join(input_tbis, by: 0, failOnDuplicate: true, failOnMismatch: true)
   .filter({ params.autosomes.tokenize(',').contains(it[0]) })

//Set up the file channels for the ref and its various index components:
//Inspired by the IARC alignment-nf pipeline
//fai is generated by samtools faidx
ref = file(params.ref, checkIfExists: true)
ref_fai = file(params.ref+'.fai', checkIfExists: true)

//Set up a file channel for the population/group metadata for +fill-tags:
region_map = file(params.sample_group_map, checkIfExists: true)

//Defaults for cpus, memory, and time for each process:
//Per-region MAF annotation:
params.perregion_maf_cpus = 1
params.perregion_maf_mem = 1
params.perregion_maf_timeout = '12h'
//MAF filtering:
params.maf_filter_cpus = 1
params.maf_filter_mem = 1
params.maf_filter_timeout = '6h'
//VCF to PLINK:
//Automatically adds 1 GiB for overhead
params.vcftoplink_cpus = 1
params.vcftoplink_mem = 4
params.vcftoplink_timeout = '6h'
//PLINK pmerge-list:
//Automatically adds 1 GiB for overhead
params.plinkmerge_cpus = 1
params.plinkmerge_mem = 4
params.plinkmerge_timeout = '6h'
//PLINK LDprune:
//Automatically adds 1 GiB for overhead
params.ldprune_cpus = 1
params.ldprune_mem = 16
params.ldprune_timeout = '6h'

process perregion_maf {
   tag "chr${chrom}"

   cpus params.perregion_maf_cpus
   memory { params.perregion_maf_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt == 2 ? '48h' : params.perregion_maf_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/MAF_annotated_VCFs", mode: 'copy', pattern: '*_MAFannotated.vcf.g{z,z.tbi}'

   input:
   tuple val(chrom), path(vcf), path(tbi) from bychrom_vcfs
   path ref
   path ref_fai
   path region_map

   output:
   tuple path("bcftools_view_minimalFilters_chr${chrom}.stderr"), path("bcftools_filltags_AF_MAF_chr${chrom}.stderr"), path("bcftools_filltags_AF_MAF_chr${chrom}.stderr") into maf_annotate_logs
   tuple val(chrom), path("${params.run_name}_chr${chrom}_MAFannotated.vcf.gz"), path("${params.run_name}_chr${chrom}_MAFannotated.vcf.gz.tbi") into maf_annotated_vcfs

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   bcftools view -i '!{params.minimal_filter_str}' !{vcf} 2> bcftools_view_minimalFilters_chr!{chrom}.stderr | \
      bcftools +fill-tags -Oz -o !{params.run_name}_chr!{chrom}_MAFannotated.vcf.gz - -- -t AF,MAF -S !{region_map} 2> bcftools_filltags_AF_MAF_chr!{chrom}.stderr > bcftools_filltags_AF_MAF_chr!{chrom}.stdout
   tabix -f !{params.run_name}_chr!{chrom}_MAFannotated.vcf.gz
   '''
}

process maf_filter {
   tag "chr${chrom}"

   cpus params.maf_filter_cpus
   memory { params.maf_filter_mem.plus(task.attempt.minus(1).multiply(8))+' GB' }
   time { task.attempt == 2 ? '48h' : params.maf_filter_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/MAF_filtered_VCFs", mode: 'copy', pattern: '*.vcf.g{z,z.tbi}'

   input:
   tuple val(chrom), path(vcf), path(tbi) from maf_annotated_vcfs
   path ref
   path ref_fai

   output:
   tuple path("bcftools_view_${params.MAF_name}_chr${chrom}.stderr"), path("bcftools_view_${params.MAF_name}_chr${chrom}.stdout") into maf_filter_logs
   tuple val(chrom), path("${params.run_name}_chr${chrom}_${params.MAF_name}.vcf.gz"), path("${params.run_name}_chr${chrom}_${params.MAF_name}.vcf.gz.tbi") into maf_filtered_vcfs

   shell:
   '''
   module load !{params.mod_bcftools}
   module load !{params.mod_htslib}
   bcftools view -Oz -o !{params.run_name}_chr!{chrom}_!{params.MAF_name}.vcf.gz -i '!{params.maf_filter_str}' !{vcf} 2> bcftools_view_!{params.MAF_name}_chr!{chrom}.stderr > bcftools_view_!{params.MAF_name}_chr!{chrom}.stdout
   tabix -f !{params.run_name}_chr!{chrom}_!{params.MAF_name}.vcf.gz
   '''
}

process vcftoplink {
   tag "chr${chrom}"

   cpus params.vcftoplink_cpus
   memory { params.vcftoplink_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '48h' : params.vcftoplink_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   tuple val(chrom), path(vcf), path(tbi) from maf_filtered_vcfs
   path ref
   path ref_fai

   output:
   tuple path("plink_makepgen_${params.MAF_name}_bSNPs_chr${chrom}.stderr"), path("plink_makepgen_${params.MAF_name}_bSNPs_chr${chrom}.stdout") into vcftoplink_logs
   tuple path("${params.run_name}_chr${chrom}_${params.MAF_name}_bSNPs.pgen"), path("${params.run_name}_chr${chrom}_${params.MAF_name}_bSNPs.pvar.zst"), path("${params.run_name}_chr${chrom}_${params.MAF_name}_bSNPs.psam") into perchrom_pgen

   shell:
   plink_mem = task.memory.minus(1.GB).toMega()
   makepgen_params = "--const-fid 0 --make-pgen vzs --snps-only --min-alleles 2 --max-alleles 2"
   '''
   module load !{params.mod_plink2}
   !{params.plink2_bin} --threads !{task.cpus} --memory !{plink_mem} !{makepgen_params} --set-missing-var-ids '@_#_$r_$a' --vcf !{vcf} --out !{params.run_name}_chr!{chrom}_!{params.MAF_name}_bSNPs 2> plink_makepgen_!{params.MAF_name}_bSNPs_chr!{chrom}.stderr > plink_makepgen_!{params.MAF_name}_bSNPs_chr!{chrom}.stdout
   '''
}

process plinkmerge {

   cpus params.plinkmerge_cpus
   memory { params.plinkmerge_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '48h' : params.plinkmerge_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'

   input:
   path("*") from perchrom_pgen.collect()
   path ref
   path ref_fai

   output:
   tuple path("plink_pmergelist_${params.MAF_name}_bSNPs.stderr"), path("plink_pmergelist_${params.MAF_name}_bSNPs.stdout") into plinkmerge_logs
   tuple path("${params.run_name}_autosomes_${params.MAF_name}_bSNPs.pgen"), path("${params.run_name}_autosomes_${params.MAF_name}_bSNPs.pvar.zst"), path("${params.run_name}_autosomes_${params.MAF_name}_bSNPs.psam") into merged_pgen

   shell:
   plink_mem = task.memory.minus(1.GB).toMega()
   '''
   module load !{params.mod_plink2}
   ls *.pgen | \
      awk '{gsub(".pgen", "");print;}' | \
      sort -k1,1V > autosome_pfile.list
   !{params.plink2_bin} --threads !{task.cpus} --memory !{plink_mem} --pmerge-list autosome_pfile.list pfile-vzs --pmerge-output-vzs --out !{params.run_name}_autosomes_!{params.MAF_name}_bSNPs 2> plink_pmergelist_!{params.MAF_name}_bSNPs.stderr > plink_pmergelist_!{params.MAF_name}_bSNPs.stdout
   '''
}

process ldprune {

   cpus params.ldprune_cpus
   memory { params.ldprune_mem.plus(1).plus(task.attempt.minus(1).multiply(16))+' GB' }
   time { task.attempt == 2 ? '48h' : params.ldprune_timeout }
   errorStrategy { task.exitStatus in ([1]+(134..140).collect()) ? 'retry' : 'terminate' }
   maxRetries 1

   publishDir path: "${params.output_dir}/logs", mode: 'copy', pattern: '*.std{err,out}'
   publishDir path: "${params.output_dir}/pruned_PLINK", mode: 'copy', pattern: '*.{bed,bim,fam}'

   input:
   tuple path(pgen), path(pvar), path(psam) from merged_pgen
   path ref
   path ref_fai

   output:
   tuple path("plink_LDprune_${params.MAF_name}_bSNPs_${params.LD_name}.stderr"), path("plink_LDprune_${params.MAF_name}_bSNPs_${params.LD_name}.stdout"), path("plink_extractLDpruned_${params.MAF_name}_bSNPs_${params.LD_name}.stderr"), path("plink_extractLDpruned_${params.MAF_name}_bSNPs_${params.LD_name}.stdout") into ldprune_logs
   tuple path("plink_makebed_${params.MAF_name}_bSNPs_${params.LD_name}.stderr"), path("plink_makebed_${params.MAF_name}_bSNPs_${params.LD_name}.stdout") optional true into ldprune_pgentobed_logs
   tuple path("${params.run_name}_autosomes_${params.MAF_name}_bSNPs_${params.LD_name}.bed"), path("${params.run_name}_autosomes_${params.MAF_name}_bSNPs_${params.LD_name}.bim"), path("${params.run_name}_autosomes_${params.MAF_name}_bSNPs_${params.LD_name}.fam") into ldprune_plink_outputs

   shell:
   plink_mem = task.memory.minus(1.GB).toMega()
   if (params.ld_pruning_algo == "--indep-pairwise")
      '''
      module load !{params.mod_plink2}
      pfileprefix=$(basename !{pgen} .pgen)
      !{params.plink2_bin} --threads !{task.cpus} --memory !{plink_mem} --pfile ${pfileprefix} vzs !{params.ld_pruning_algo} !{params.ld_pruning_params} --out !{params.run_name}_autosomes_!{params.MAF_name}_bSNPs_!{params.LD_name} 2> plink_LDprune_!{params.MAF_name}_bSNPs_!{params.LD_name}.stderr > plink_LDprune_!{params.MAF_name}_bSNPs_!{params.LD_name}.stdout
      !{params.plink2_bin} --threads !{task.cpus} --memory !{plink_mem} --pfile ${pfileprefix} vzs --extract !{params.run_name}_autosomes_!{params.MAF_name}_bSNPs_!{params.LD_name}.prune.in --make-bed --out !{params.run_name}_autosomes_!{params.MAF_name}_bSNPs_!{params.LD_name} 2> plink_extractLDpruned_!{params.MAF_name}_bSNPs_!{params.LD_name}.stderr > plink_extractLDpruned_!{params.MAF_name}_bSNPs_!{params.LD_name}.stdout
      '''
   else
      '''
      module load !{params.mod_plink2}
      pfileprefix=$(basename !{pgen} .pgen)
      !{params.plink2_bin} --threads !{task.cpus} --memory !{plink_mem} --pfile ${pfileprefix} vzs --out ${pfileprefix} --make-bed 2> plink_makebed_!{params.MAF_name}_bSNPs_!{params.LD_name}.stderr > plink_makebed_!{params.MAF_name}_bSNPs_!{params.LD_name}.stdout
      module unload !{params.mod_plink2}
      module load !{params.mod_plink19}
      !{params.plink19_bin} --threads !{task.cpus} --memory !{plink_mem} --bfile ${pfileprefix} !{params.ld_pruning_algo} !{params.ld_pruning_params} --out !{params.run_name}_autosomes_!{params.MAF_name}_bSNPs_!{params.LD_name} 2> plink_LDprune_!{params.MAF_name}_bSNPs_!{params.LD_name}.stderr > plink_LDprune_!{params.MAF_name}_bSNPs_!{params.LD_name}.stdout
      !{params.plink19_bin} --threads !{task.cpus} --memory !{plink_mem} --bfile ${pfileprefix} --extract !{params.run_name}_autosomes_!{params.MAF_name}_bSNPs_!{params.LD_name}.prune.in --make-bed --out !{params.run_name}_autosomes_!{params.MAF_name}_bSNPs_!{params.LD_name} 2> plink_extractLDpruned_!{params.MAF_name}_bSNPs_!{params.LD_name}.stderr > plink_extractLDpruned_!{params.MAF_name}_bSNPs_!{params.LD_name}.stdout
      '''
}
